{
  UnInvertedField.log.info("setMultyValue " + this.field + " field "+ this.isMultiValued+ "@"+ key);
  int maxDoc=reader.maxDoc();
  int maxDocOffset=maxDoc + 2;
  this.index=INT_BUFFER.calloc(maxDocOffset,BigReUsedBuffer.INT_CREATE,-1);
  int[] docs=new int[1000];
  int[] freqs=new int[1000];
  final byte[][] bytes=new byte[maxDoc][];
  this.maxTermNum=0;
  byte[] tempArr=new byte[12];
  final int[] lastTerm=new int[maxDoc];
  for (; ; ) {
    Term t=te.term();
    if (t == null) {
      break;
    }
    int termNum=te.getTermNumber();
    maxTermNum=Math.max(maxTermNum,termNum);
    termsInverted++;
    TermDocs td=te.getTermDocs();
    td.seek(te);
    for (; ; ) {
      int n=td.read(docs,freqs);
      if (n <= 0) {
        break;
      }
      for (int i=0; i < n; i++) {
        termInstances++;
        int doc=docs[i];
        int delta=termNum - lastTerm[doc] + TNUM_OFFSET;
        lastTerm[doc]=termNum;
        int val=index.get(doc);
        if ((val & 0xff) == 1) {
          int pos=val >>> 8;
          int ilen=UnInvertedFieldUtils.vIntSize(delta);
          byte[] arr=bytes[doc];
          int newend=pos + ilen;
          if (newend > arr.length) {
            int newLen=(newend + 3) & 0xfffffffc;
            byte[] newarr=new byte[newLen];
            System.arraycopy(arr,0,newarr,0,pos);
            arr=newarr;
            bytes[doc]=newarr;
          }
          pos=UnInvertedFieldUtils.writeInt(delta,arr,pos);
          index.set(doc,(pos << 8) | 1);
        }
 else {
          int ipos;
          if (val == 0) {
            ipos=0;
          }
 else           if ((val & 0x0000ff80) == 0) {
            ipos=1;
          }
 else           if ((val & 0x00ff8000) == 0) {
            ipos=2;
          }
 else           if ((val & 0xff800000) == 0) {
            ipos=3;
          }
 else {
            ipos=4;
          }
          int endPos=UnInvertedFieldUtils.writeInt(delta,tempArr,ipos);
          if (endPos <= 4) {
            for (int j=ipos; j < endPos; j++) {
              val|=(tempArr[j] & 0xff) << (j << 3);
            }
            index.set(doc,val);
          }
 else {
            for (int j=0; j < ipos; j++) {
              tempArr[j]=(byte)val;
              val>>>=8;
            }
            index.set(doc,(endPos << 8) | 1);
            bytes[doc]=tempArr;
            tempArr=new byte[12];
          }
        }
      }
    }
    te.next();
  }
  if (termInstances == 0) {
    INT_BUFFER.free(this.index);
    this.index=null;
    tnums=null;
  }
 else {
    tnums=new byte[256][];
    for (int pass=0; pass < 256; pass++) {
      byte[] target=tnums[pass];
      int pos=0;
      if (target != null) {
        pos=target.length;
      }
 else {
        target=new byte[4096];
      }
      for (int docbase=pass << 16; docbase < maxDoc; docbase+=(1 << 24)) {
        int lim=Math.min(docbase + (1 << 16),maxDoc);
        for (int doc=docbase; doc < lim; doc++) {
          int val=index.get(doc);
          if ((val & 0xff) == 1) {
            int len=val >>> 8;
            index.set(doc,(pos << 8) | 1);
            if ((pos & 0xff000000) != 0) {
              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"Too many values for UnInvertedField faceting on field " + field);
            }
            byte[] arr=bytes[doc];
            bytes[doc]=null;
            if (target.length <= pos + len) {
              int newlen=target.length;
              while (newlen <= pos + len)               newlen<<=1;
              byte[] newtarget=new byte[newlen];
              System.arraycopy(target,0,newtarget,0,pos);
              target=newtarget;
            }
            System.arraycopy(arr,0,target,pos,len);
            pos+=len + 1;
          }
        }
      }
      if (pos < target.length) {
        byte[] newtarget=new byte[pos];
        System.arraycopy(target,0,newtarget,0,pos);
        target=newtarget;
        if (target.length > (1 << 24) * .9) {
          SolrCore.log.warn("Approaching too many values for UnInvertedField faceting on field '" + field + "' : bucket size="+ target.length);
        }
      }
      tnums[pass]=target;
      if ((pass << 16) > maxDoc)       break;
    }
    int finalTerm=maxTermNum + 2;
    this.setFinalIndex(-1,finalTerm);
  }
}
