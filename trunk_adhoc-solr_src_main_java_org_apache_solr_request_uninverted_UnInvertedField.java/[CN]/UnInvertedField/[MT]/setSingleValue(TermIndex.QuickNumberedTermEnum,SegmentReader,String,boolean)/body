{
  UnInvertedField.log.info("setSingleValue QuickNumberedTermEnum " + this.field + " field "+ this.isMultiValued+ "@"+ key);
  int maxDoc=reader.maxDoc();
  int maxDocOffset=maxDoc + 2;
  this.index=INT_BUFFER.calloc(maxDocOffset,BigReUsedBuffer.INT_CREATE,-1);
  int[] docs=new int[1000];
  int[] freqs=new int[1000];
  if (isReadDouble) {
    if (this.dataType == Datatype.d_long || this.dataType == Datatype.d_string) {
      this.termValueLong=LONG_BUFFER.calloc(maxDocOffset,BigReUsedBuffer.LONG_CREATE,(long)MINVALUE_FILL);
    }
    if (this.dataType == Datatype.d_double) {
      this.termValueDouble=DOUBLE_BUFFER.calloc(maxDocOffset,BigReUsedBuffer.DOUBLE_CREATE,MINVALUE_FILL);
    }
  }
  FieldInfo fi=reader.getFieldInfo().fieldInfo(this.field);
  IndexOptions indexOptions=(fi != null) ? fi.indexOptions : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
  boolean currentFieldStoresPayloads=(fi != null) ? fi.storePayloads : false;
  this.maxTermNum=0;
  while (te.next()) {
    int termNum=te.getTermNumber();
    termsInverted++;
    SegmentTermDocs td=reader.SegmentTermDocs(1024);
    td.seekDocs(te.getDocPos(),te.getDocCount(),indexOptions,currentFieldStoresPayloads);
    for (; ; ) {
      int n=td.read(docs,freqs);
      if (n <= 0) {
        break;
      }
      for (int i=0; i < n; i++) {
        termInstances++;
        this.index.set(docs[i],termNum);
      }
    }
    maxTermNum=Math.max(maxTermNum,termNum);
    if (isReadDouble) {
      if (dataType == Datatype.d_long) {
        this.termValueLong.set(termNum,te.getVVVlong());
      }
 else       if (dataType == Datatype.d_double) {
        this.termValueDouble.set(termNum,Double.longBitsToDouble(te.getVVVlong()));
      }
 else       if (dataType == Datatype.d_string) {
        this.termValueLong.set(termNum,te.getVVVlong());
      }
    }
  }
  if (termInstances == 0) {
    INT_BUFFER.free(this.index);
    this.index=null;
  }
 else {
    int nullTerm=maxTermNum + 1;
    int finalTerm=maxTermNum + 2;
    this.setFinalIndex(nullTerm,finalTerm);
    if (isReadDouble) {
      if (this.dataType == Datatype.d_long || this.dataType == Datatype.d_string) {
        BlockArray<Long> bigTermValue=this.termValueLong;
        int size=bigTermValue.getSize();
        this.termValueLong=LONG_BUFFER.calloc(finalTerm,BigReUsedBuffer.LONG_CREATE,(long)MINVALUE_FILL);
        for (int i=0; i < finalTerm && i < size; i++) {
          Long v=bigTermValue.get(i);
          this.termValueLong.set(i,v);
        }
        this.termValueLong.set(nullTerm,(long)MINVALUE_FILL);
        LONG_BUFFER.free(bigTermValue);
        bigTermValue=null;
      }
      if (this.dataType == Datatype.d_double) {
        BlockArray<Double> bigTermValue=this.termValueDouble;
        int size=bigTermValue.getSize();
        this.termValueDouble=DOUBLE_BUFFER.calloc(finalTerm,BigReUsedBuffer.DOUBLE_CREATE,MINVALUE_FILL);
        for (int i=0; i < finalTerm && i < size; i++) {
          Double v=bigTermValue.get(i);
          this.termValueDouble.set(i,v);
        }
        this.termValueDouble.set(nullTerm,MINVALUE_FILL);
        DOUBLE_BUFFER.free(bigTermValue);
        bigTermValue=null;
      }
    }
  }
}
