{
  boolean isfacet=params.getBool(FacetParams.FACET_CROSS,false);
  int size=lst.size();
  Integer maxshards=params.getInt(FacetParams.MERGER_MAX_SHARDS,UniqConfig.getMaxMergerShard());
  HashMap<String,AssginShard> host2AssginShard=assignByHost(lst,mslist);
  int hostsize=host2AssginShard.size();
  if ((maxshards >= size && hostsize <= 1) || !isfacet) {
    rb.lockType=ResponseBuilder.RequestLockType.shards;
    rb.shards=lst.toArray(new String[lst.size()]);
    log.info("MergerSchedule shards:" + Arrays.toString(rb.shards));
    return;
  }
  ArrayList<AssginShard> result=new ArrayList<AssginShard>();
  int requestCount=hostsize;
  if (hostsize > maxshards) {
    requestCount=maxshards;
  }
  for (int i=0; i < requestCount; i++) {
    result.add(new AssginShard(new ArrayList<String>(),new ArrayList<String>()));
  }
  int selectindex=0;
  for (  Entry<String,AssginShard> e : host2AssginShard.entrySet()) {
    AssginShard as=e.getValue();
    AssginShard toadd=result.get(selectindex % requestCount);
    toadd.ms.addAll(as.ms);
    toadd.shards.addAll(as.shards);
    selectindex++;
  }
  if (hostsize <= 1) {
    rb.lockType=ResponseBuilder.RequestLockType.singlehosts;
    scheduleSingleHost(result.get(0),rb,maxshards);
    return;
  }
  int shardcnt=result.size();
  rb.lockType=ResponseBuilder.RequestLockType.multy;
  rb.shards=new String[shardcnt];
  rb.subShards=new String[shardcnt];
  rb.issubshard=true;
  for (int i=0; i < shardcnt; i++) {
    AssginShard as=result.get(i);
    rb.shards[i]=as.randomMerger();
    StringBuffer subShards=new StringBuffer();
    String joinchar="";
    for (    String s : as.shards) {
      subShards.append(joinchar);
      subShards.append(s);
      joinchar=",";
    }
    rb.subShards[i]=subShards.toString();
    log.info("MergerSchedule host:" + rb.shards[i] + "=>>"+ rb.subShards[i]);
  }
}
