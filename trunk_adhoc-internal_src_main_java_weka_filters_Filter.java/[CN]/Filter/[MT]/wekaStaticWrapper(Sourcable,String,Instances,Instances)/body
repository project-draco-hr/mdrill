{
  StringBuffer result;
  int i;
  int n;
  result=new StringBuffer();
  result.append("// Generated with Weka " + Version.VERSION + "\n");
  result.append("//\n");
  result.append("// This code is public domain and comes with no warranty.\n");
  result.append("//\n");
  result.append("// Timestamp: " + new Date() + "\n");
  result.append("// Relation: " + input.relationName() + "\n");
  result.append("\n");
  result.append("package weka.filters;\n");
  result.append("\n");
  result.append("import weka.core.Attribute;\n");
  result.append("import weka.core.Capabilities;\n");
  result.append("import weka.core.Capabilities.Capability;\n");
  result.append("import weka.core.FastVector;\n");
  result.append("import weka.core.Instance;\n");
  result.append("import weka.core.Instances;\n");
  result.append("import weka.filters.Filter;\n");
  result.append("\n");
  result.append("public class WekaWrapper\n");
  result.append("  extends Filter {\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * Returns only the toString() method.\n");
  result.append("   *\n");
  result.append("   * @return a string describing the filter\n");
  result.append("   */\n");
  result.append("  public String globalInfo() {\n");
  result.append("    return toString();\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * Returns the capabilities of this filter.\n");
  result.append("   *\n");
  result.append("   * @return the capabilities\n");
  result.append("   */\n");
  result.append("  public Capabilities getCapabilities() {\n");
  result.append(((Filter)filter).getCapabilities().toSource("result",4));
  result.append("    return result;\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * turns array of Objects into an Instance object\n");
  result.append("   *\n");
  result.append("   * @param obj	the Object array to turn into an Instance\n");
  result.append("   * @param format	the data format to use\n");
  result.append("   * @return		the generated Instance object\n");
  result.append("   */\n");
  result.append("  protected Instance objectsToInstance(Object[] obj, Instances format) {\n");
  result.append("    Instance		result;\n");
  result.append("    double[]		values;\n");
  result.append("    int		i;\n");
  result.append("\n");
  result.append("    values = new double[obj.length];\n");
  result.append("\n");
  result.append("    for (i = 0 ; i < obj.length; i++) {\n");
  result.append("      if (obj[i] == null)\n");
  result.append("        values[i] = Instance.missingValue();\n");
  result.append("      else if (format.attribute(i).isNumeric())\n");
  result.append("        values[i] = (Double) obj[i];\n");
  result.append("      else if (format.attribute(i).isNominal())\n");
  result.append("        values[i] = format.attribute(i).indexOfValue((String) obj[i]);\n");
  result.append("    }\n");
  result.append("\n");
  result.append("    // create new instance\n");
  result.append("    result = new Instance(1.0, values);\n");
  result.append("    result.setDataset(format);\n");
  result.append("\n");
  result.append("    return result;\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * turns the Instance object into an array of Objects\n");
  result.append("   *\n");
  result.append("   * @param inst	the instance to turn into an array\n");
  result.append("   * @return		the Object array representing the instance\n");
  result.append("   */\n");
  result.append("  protected Object[] instanceToObjects(Instance inst) {\n");
  result.append("    Object[]	result;\n");
  result.append("    int		i;\n");
  result.append("\n");
  result.append("    result = new Object[inst.numAttributes()];\n");
  result.append("\n");
  result.append("    for (i = 0 ; i < inst.numAttributes(); i++) {\n");
  result.append("      if (inst.isMissing(i))\n");
  result.append("  	result[i] = null;\n");
  result.append("      else if (inst.attribute(i).isNumeric())\n");
  result.append("  	result[i] = inst.value(i);\n");
  result.append("      else\n");
  result.append("  	result[i] = inst.stringValue(i);\n");
  result.append("    }\n");
  result.append("\n");
  result.append("    return result;\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * turns the Instances object into an array of Objects\n");
  result.append("   *\n");
  result.append("   * @param data	the instances to turn into an array\n");
  result.append("   * @return		the Object array representing the instances\n");
  result.append("   */\n");
  result.append("  protected Object[][] instancesToObjects(Instances data) {\n");
  result.append("    Object[][]	result;\n");
  result.append("    int		i;\n");
  result.append("\n");
  result.append("    result = new Object[data.numInstances()][];\n");
  result.append("\n");
  result.append("    for (i = 0; i < data.numInstances(); i++)\n");
  result.append("      result[i] = instanceToObjects(data.instance(i));\n");
  result.append("\n");
  result.append("    return result;\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * Only tests the input data.\n");
  result.append("   *\n");
  result.append("   * @param instanceInfo the format of the data to convert\n");
  result.append("   * @return always true, to indicate that the output format can \n");
  result.append("   *         be collected immediately.\n");
  result.append("   */\n");
  result.append("  public boolean setInputFormat(Instances instanceInfo) throws Exception {\n");
  result.append("    super.setInputFormat(instanceInfo);\n");
  result.append("    \n");
  result.append("    // generate output format\n");
  result.append("    FastVector atts = new FastVector();\n");
  result.append("    FastVector attValues;\n");
  for (i=0; i < output.numAttributes(); i++) {
    result.append("    // " + output.attribute(i).name() + "\n");
    if (output.attribute(i).isNumeric()) {
      result.append("    atts.addElement(new Attribute(\"" + output.attribute(i).name() + "\"));\n");
    }
 else     if (output.attribute(i).isNominal()) {
      result.append("    attValues = new FastVector();\n");
      for (n=0; n < output.attribute(i).numValues(); n++) {
        result.append("    attValues.addElement(\"" + output.attribute(i).value(n) + "\");\n");
      }
      result.append("    atts.addElement(new Attribute(\"" + output.attribute(i).name() + "\", attValues));\n");
    }
 else {
      throw new UnsupportedAttributeTypeException("Attribute type '" + output.attribute(i).type() + "' (position "+ (i + 1)+ ") is not supported!");
    }
  }
  result.append("    \n");
  result.append("    Instances format = new Instances(\"" + output.relationName() + "\", atts, 0);\n");
  result.append("    format.setClassIndex(" + output.classIndex() + ");\n");
  result.append("    setOutputFormat(format);\n");
  result.append("    \n");
  result.append("    return true;\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * Directly filters the instance.\n");
  result.append("   *\n");
  result.append("   * @param instance the instance to convert\n");
  result.append("   * @return always true, to indicate that the output can \n");
  result.append("   *         be collected immediately.\n");
  result.append("   */\n");
  result.append("  public boolean input(Instance instance) throws Exception {\n");
  result.append("    Object[] filtered = " + className + ".filter(instanceToObjects(instance));\n");
  result.append("    push(objectsToInstance(filtered, getOutputFormat()));\n");
  result.append("    return true;\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * Performs a batch filtering of the buffered data, if any available.\n");
  result.append("   *\n");
  result.append("   * @return true if instances were filtered otherwise false\n");
  result.append("   */\n");
  result.append("  public boolean batchFinished() throws Exception {\n");
  result.append("    if (getInputFormat() == null)\n");
  result.append("      throw new NullPointerException(\"No input instance format defined\");;\n");
  result.append("\n");
  result.append("    Instances inst = getInputFormat();\n");
  result.append("    if (inst.numInstances() > 0) {\n");
  result.append("      Object[][] filtered = " + className + ".filter(instancesToObjects(inst));\n");
  result.append("      for (int i = 0; i < filtered.length; i++) {\n");
  result.append("        push(objectsToInstance(filtered[i], getOutputFormat()));\n");
  result.append("      }\n");
  result.append("    }\n");
  result.append("\n");
  result.append("    flushInput();\n");
  result.append("    m_NewBatch = true;\n");
  result.append("    m_FirstBatchDone = true;\n");
  result.append("\n");
  result.append("    return (inst.numInstances() > 0);\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * Returns only the classnames and what filter it is based on.\n");
  result.append("   *\n");
  result.append("   * @return a short description\n");
  result.append("   */\n");
  result.append("  public String toString() {\n");
  result.append("    return \"Auto-generated filter wrapper, based on " + filter.getClass().getName() + " (generated with Weka "+ Version.VERSION+ ").\\n"+ "\" + this.getClass().getName() + \"/"+ className+ "\";\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * Runs the filter from commandline.\n");
  result.append("   *\n");
  result.append("   * @param args the commandline arguments\n");
  result.append("   */\n");
  result.append("  public static void main(String args[]) {\n");
  result.append("    runFilter(new WekaWrapper(), args);\n");
  result.append("  }\n");
  result.append("}\n");
  result.append("\n");
  result.append(filter.toSource(className,input));
  return result.toString();
}
