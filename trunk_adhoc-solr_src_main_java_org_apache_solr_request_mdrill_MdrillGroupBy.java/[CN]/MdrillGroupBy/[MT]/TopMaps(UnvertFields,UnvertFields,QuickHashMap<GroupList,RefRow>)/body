{
  long t1=System.currentTimeMillis();
  int groupsize=groups.size();
  if (groupsize <= this.limit_offset) {
    return;
  }
  PriorityQueue<ShardGroupByTermNum> res=new PriorityQueue<ShardGroupByTermNum>(this.limit_offset,Collections.reverseOrder(this.cmpTermNum));
  LinkedBlockingQueue<GroupList> toremove=new LinkedBlockingQueue<MdrillPorcessUtils.GroupList>();
  ;
  QuickHashMap<GroupList,RefRow> debug=new QuickHashMap<MdrillPorcessUtils.GroupList,MdrillPorcessUtils.RefRow>(this.limit_offset);
  for (  Entry<GroupList,RefRow> e : groups.entrySet()) {
    debug.put(e.getKey(),e.getValue());
    ShardGroupByTermNum mrow=new ShardGroupByTermNum(e.getKey(),e.getValue());
    if (res.size() < limit_offset) {
      res.add(mrow);
    }
 else     if (this.cmpTermNum.compare(res.peek(),mrow) > 0) {
      res.add(mrow);
      ShardGroupByTermNum free=res.poll();
      toremove.add(free.key);
    }
 else {
      toremove.add(mrow.key);
    }
  }
  int cnt1=0;
  for (  GroupList torm : toremove) {
    groups.remove(torm);
    this.groupListCache.add(torm);
    cnt1++;
  }
  smallestShardGroup=res.peek();
  long t2=System.currentTimeMillis();
  LOG.info("TopMaps groups.size=" + groupsize + "@"+ debug.size()+ " to "+ groups.size()+ "@"+ this.limit_offset+ ",res.size="+ res.size()+ ",remove="+ cnt1+ ",timetaken="+ (t2 - t1)+ ",mergercount="+ mergercount);
}
