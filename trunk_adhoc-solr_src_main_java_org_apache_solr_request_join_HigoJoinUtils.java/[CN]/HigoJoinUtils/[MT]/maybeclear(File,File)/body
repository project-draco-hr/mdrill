{
  String key=basedir.getAbsolutePath();
  Long expirestimes=cleartimes.contains(key) ? cleartimes.get(key) + checkinterval : checkinterval;
  long nowtimes=System.currentTimeMillis();
  if (expirestimes > nowtimes) {
    LOG.info("nonclean " + key + ","+ expirestimes+ ","+ nowtimes);
    return;
  }
  LOG.info("begin clean " + key + ","+ expirestimes+ ","+ nowtimes);
  cleartimes.put(key,nowtimes);
  File lockPath=new File(lockbase,"higo_clear_lock");
  if (!lockbase.exists()) {
    lockbase.mkdirs();
  }
  if (!lockPath.exists()) {
    lockPath.createNewFile();
  }
  FileLock flout=null;
  RandomAccessFile out=null;
  FileChannel fcout=null;
  try {
    out=new RandomAccessFile(lockPath,"rw");
    fcout=out.getChannel();
    flout=fcout.lock();
    Configuration conf=getConf();
    FileSystem lfs=FileSystem.getLocal(conf);
    Path basepath=new Path(key);
    if (!lfs.exists(basepath)) {
      return;
    }
    FileStatus[] list=lfs.listStatus(basepath);
    if (list == null) {
      return;
    }
    long cleantimes=nowtimes - cleanTimesinterval;
    ArrayList<Path> toremove=new ArrayList<Path>();
    ArrayList<cleanPair> toSave=new ArrayList<cleanPair>();
    for (    FileStatus s : list) {
      if (!s.isDir()) {
        continue;
      }
      long lasttimes=Math.max(s.getAccessTime(),s.getModificationTime());
      if (lasttimes < cleantimes) {
        LOG.info("drop " + s.getAccessTime() + ","+ s.getModificationTime()+ ","+ cleantimes+ ","+ s.getPath().toString());
        toremove.add(s.getPath());
      }
 else {
        toSave.add(new cleanPair(s.getPath(),lasttimes));
      }
    }
    for (    Path p : toremove) {
      lfs.delete(p,true);
    }
    if (toSave.size() <= checkMaxDirCount) {
      return;
    }
    Collections.sort(toSave,new Comparator<cleanPair>(){
      @Override public int compare(      cleanPair o1,      cleanPair o2){
        return o2.t.compareTo(o1.t);
      }
    }
);
    for (int i=checkMaxDirCount; i < toSave.size(); i++) {
      cleanPair p=toSave.get(i);
      lfs.delete(p.p,true);
    }
  }
  finally {
    try {
      if (flout != null) {
        flout.release();
      }
      if (fcout != null) {
        fcout.close();
      }
      if (out != null) {
        out.close();
      }
      out=null;
    }
 catch (    Exception e) {
    }
    lockPath.delete();
  }
}
