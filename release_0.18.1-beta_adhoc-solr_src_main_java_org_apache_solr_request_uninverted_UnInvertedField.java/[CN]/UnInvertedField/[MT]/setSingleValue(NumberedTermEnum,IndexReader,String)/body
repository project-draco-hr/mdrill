{
  UnInvertedField.log.info("setSingleValue " + this.field + " field "+ this.isMultiValued+ "@"+ key);
  int maxDoc=reader.maxDoc();
  int maxDocOffset=maxDoc + 2;
  this.index=INT_BUFFER.calloc(maxDocOffset,BigReUsedBuffer.INT_CREATE,-1);
  int[] docs=new int[1000];
  int[] freqs=new int[1000];
  if (this.dataType == Datatype.d_long || this.dataType == Datatype.d_string) {
    this.termValueLong=LONG_BUFFER.calloc(maxDocOffset,BigReUsedBuffer.LONG_CREATE,(long)MINVALUE_FILL);
  }
  if (this.dataType == Datatype.d_double) {
    this.termValueDouble=DOUBLE_BUFFER.calloc(maxDocOffset,BigReUsedBuffer.DOUBLE_CREATE,MINVALUE_FILL);
  }
  this.maxTermNum=0;
  for (; ; ) {
    Term t=te.term();
    if (t == null) {
      break;
    }
    int termNum=te.getTermNumber();
    termsInverted++;
    TermDocs td=te.getTermDocs();
    td.seek(te);
    for (; ; ) {
      int n=td.read(docs,freqs);
      if (n <= 0) {
        break;
      }
      for (int i=0; i < n; i++) {
        termInstances++;
        this.index.set(docs[i],termNum);
      }
    }
    maxTermNum=Math.max(maxTermNum,termNum);
    if (dataType == Datatype.d_long) {
      this.termValueLong.set(termNum,Long.parseLong(ft.indexedToReadable(t.text())));
    }
 else     if (dataType == Datatype.d_double) {
      this.termValueDouble.set(termNum,MdrillPorcessUtils.ParseDouble(ft.indexedToReadable(t.text())));
    }
 else     if (dataType == Datatype.d_string) {
      CRC32 crc32=new CRC32();
      crc32.update(new String(ft.indexedToReadable(t.text())).getBytes());
      this.termValueLong.set(termNum,crc32.getValue());
    }
    te.next();
  }
  if (termInstances == 0) {
    INT_BUFFER.free(this.index);
    this.index=null;
  }
 else {
    int nullTerm=maxTermNum + 1;
    int finalTerm=maxTermNum + 2;
    this.setFinalIndex(nullTerm,finalTerm);
    if (this.dataType == Datatype.d_long || this.dataType == Datatype.d_string) {
      BlockArray<Long> bigTermValue=this.termValueLong;
      int size=bigTermValue.getSize();
      this.termValueLong=LONG_BUFFER.calloc(finalTerm,BigReUsedBuffer.LONG_CREATE,(long)MINVALUE_FILL);
      for (int i=0; i < finalTerm && i < size; i++) {
        Long v=bigTermValue.get(i);
        this.termValueLong.set(i,v);
      }
      this.termValueLong.set(nullTerm,(long)MINVALUE_FILL);
      LONG_BUFFER.free(bigTermValue);
      bigTermValue=null;
    }
    if (this.dataType == Datatype.d_double) {
      BlockArray<Double> bigTermValue=this.termValueDouble;
      int size=bigTermValue.getSize();
      this.termValueDouble=DOUBLE_BUFFER.calloc(finalTerm,BigReUsedBuffer.DOUBLE_CREATE,MINVALUE_FILL);
      for (int i=0; i < finalTerm && i < size; i++) {
        Double v=bigTermValue.get(i);
        this.termValueDouble.set(i,v);
      }
      this.termValueDouble.set(nullTerm,MINVALUE_FILL);
      DOUBLE_BUFFER.free(bigTermValue);
      bigTermValue=null;
    }
  }
}
